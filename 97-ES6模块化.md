# ES6 模块化 

## 模块化介绍

### 模块化的好处：

+ 复用性好
+ 可维护性好
+ 大家都遵守同样的模块化规范写代码，**降低了沟通的成本，极大方便了各个模块之间的相互调用**



### 模块化的分类

在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了`AMD`、`CMD`、`CommonJS` 等模块化规范。

但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化
标准，例如：

+ `AMD` 和 `CMD` 适用于**浏览器端**的 JS 模块化
+ `CommonJS` 适用于**服务器端**的 JS 模块化

太多的模块化规范给开发者增加了**学习的难度与开发的成本**。因此，官方的ES6 模块化规范诞生了！



### 为什么要学习ES6 模块化规范

ES6 模块化规范是 **浏览器端与服务器端** **通用** 的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。

ES6 模块化规范中定义：

+ 每个 js 文件都是一个独立的模块
+ 导入 : : 导入其它模块成员使用 `import`  关键字
+ 导出 : : 向外共享模块成员使用 `export` 关键字 

### 如何演示

```js
1. 确保安装了 `v14.15.1` 或更高版本的 node.js
2. 在 package.json 的根节点中添加 `"type": "module"` 节点
3. 引入的文件 记得加 .js 后缀
   例如 import res from './a.js'  (以后工作项目中就不需要加.js后缀了) 
```



## ES6模块语法

 3 种用法：

+ 默认导出与默认导入
+ 按需导出与按需导入
+ 直接导入并执行模块中的代码

## 一.默认导出与默认导入(a.js)

默认导出的语法： `export default 默认导出的成员`

默认导入的语法： `import 接收名称 from '模块路径'`

+ 导出

```jsx
const a = 10
const b = 20

const fn  = () => {
  console.log('这是一个函数')
}

// 默认导出
// export default a  // 导出一个值
export default {
  a,
  b,
  fn
}
```

+ 导入

```jsx
// 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可
import res from './xxx.js'
console.log(res)
```

**注意点:** 

1. 每个模块中，只允许使用唯一的一次 `export default `

2. 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可



## 二.按需导入与按需导出(b.js)

按需导出的语法： `export const s1 = 10`

按需导入的语法： `import { 按需导入的名称 } from '模块标识符'`

```jsx
export let a = 10
export let b = 20
export let fn = () => {
  console.log('内容')
}
```

按需导入的语法

```jsx
import { a, b as c, fn } from './xxx.js'
```

注意事项：

1. 每个模块中可以有多次按需导出

2. 按需导入的成员名称必须和按需导出的名称保持一致

3. 按需导入时，可以使用 as 关键字进行重命名

   


## 三.直接导入模块(没有导出 c.js) 

如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。

此时，可以直接导入并执行模块代码，示例代码如下：

`import '模块的路径'`

```jsx
//c.js
for (let i = 0; i < 10; i++) {
  console.log(i)
}


// 导入该模块
import './c.js'
```

- 一般用在框架中的 引入 css 

```
import 'element-ui/lib/theme-chalk/index.css';
```

 

# EventLoop

##  JavaScript 是单线程的语言

> JavaScript 是一门单线程执行的编程语言。也就是说，同一时间只能做一件事情。

![](.\images\image-20201229130924682.png)

单线程执行任务队列的问题：
如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致**程序假死**的问题。

阻塞!!!!!!!



## 同步任务和异步任务

为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类：

+ 同步任务（synchronous）
  + 又叫做非耗时任务，指的是在主线程上排队执行的那些任务
  + 只有前一个任务执行完毕，才能执行后一个任务
  + 阻塞
+ 异步任务（asynchronous）
  + 又叫做耗时任务，异步任务由JavaScript 委托给宿主环境(浏览器 nodejs)进行执行
  + 当异步任务执行完成后，会通知 JavaScript 主线程执行异步任务的回调函数
  + 非阻塞

## EventLoop执行过程

+ 同步任务由 JavaScript 主线程次序执行
+ 异步任务委托给宿主环境执行
+ 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行
+ JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，次序执行
+ JavaScript 主线程不断重复上面的第 4 步

![image-20201229131612232](.\images\image-20201229131612232.png)

![](.\images\事件循环.png)

- **什么是事件循环 ?**

  JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到调用栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。(背下来)

> 就是事件循环在一次一次的轮询

