> 能够说出函数的作用 
>
> 能够说出声明与调用函数的语法 
>
> 能够说出函数的形参和实参的区别 
>
> 能够使用return返回函数的结果

## 函数

>函数的定义：一堆特定代码的集合体，它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性，一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏

简单理解: 函数可以理解为一个 `特定的代码块` 容器 ，它可以完成特定的需求, 并且可以 `重复` 使用

### 函数声明(创建函数)和函数调用(使用函数)

> 需求: 让99乘法表在不同的地方使用 ?

```js
// 声明一个函数
function 函数名 (){
    // 函数体
}

// 调用对应的函数
函数名();
```
特点说明：
1. 函数默认不会主动执行,必须通过`函数名()` 调用才会执行. 
2. 函数一次声明可以多次调用,每一次函数调用`函数体里面的代码`会重新执行一次.
3. 函数的命名尽量遵守`动词`或者`动词+名词`的方式,这样函数的作用一目了然.
4. 我们曾经使用的 `alert(),prompt() confirm()`, 这种名字后面跟小括号的本质都是函数的调用 
5. 思考小问题: 函数的复用和循环的重复有什么不同? => 循环的重复是一次性重复完毕, 函数的复用是可以自由的选择

提问:

1. 函数的作用?
2. 函数的基本使用?
3. 函数是否会主动执行?
4. 我们以前都用过哪些函数调用?

> 练习:

```js
1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
```
问: 上述代码块包装成函数有什么缺陷么?

### 函数传参

> 把函数在复用过程中会`改变`的值提取出来, 作为`参数`传递进去.这样可以极大提高函数的复用性

> 需求: 封装一个可以跟任何人打招呼的函数


```javascript
// 带参数的函数声明 
function 函数名(形参1, 形参2, 形参3...){
  // 函数体里面的值使用形参代替
}

// 带参数的函数调用
函数名(实参1, 实参2, 实参3);
```

说明:

1. 术语1: 在声明函数的小括号里面写的数值我们称之为形式参数 参数和参数之间使用逗号隔开
 	2. 术语2: 在调用函数的小括号里面写的数值我们称之为实际参数 参数和参数之间使用逗号隔开
 	3. 形参作用: 本质上就是在函数内部声明变量
  4. 实参作用: 给形参这个变量赋值
5. 我们曾经使用过的 alert('打印'), Number('11'), push('内容'), console.log('打印的内容'), document.write() 本质上都是函数调用的传参

提问:

1. 什么是函数传参? 为什么需要使用函数传参?
2. 函数传参的使用步骤 ?  => 三步
   1. 在调用的时候将真正的取值传递进来
   2. 在声明的时候接受传递过来的取值
   3. 在函数里面使用参数(形参)
3. 我们之前使用过哪些函数传参 ?

> 练习：

```js
1. 计算1-n之间所有数的和
2. 计算m-n之间所有数的和 
3. 学生的分数是一个数组,计算每个学生的总分 
```

技巧: 在初学阶段, 可以直接写死一种情况, 然后在考虑将可变的值当做参数提取出来

### 函数的返回值

> 那些年我们使用过的返回值

```js
// 下面都是我们使用过的函数返回值的情况. 
let result = prompt('请输入你的年龄?');		
let result2 = confirm('你确定要删除这条记录么?');
// 但不是所有的函数都有返回值的, 比如: alert() 
let result4 = alert('弹出一个内容');
```

问: 上述函数返回值是JS底层自动返回的. 但如果我们自己定义的函数,如何拥有返回值呢??

> 通俗的讲: 就是函数体里面 `return` 后面的值

```js
function doSomething(){
    // doing
    return result;
}

let jieguo = doSomething();
```

> 使用场景说明

需求: 调用两次求和函数,得到每一次求和的结果,再比较这两个结果的大小

```js
// 函数里面声明的sum变量,外面是拿不到的.
function getSum(a, b) {
  let sum = a + b;
  return sum;
}

let sum1 = getSum(10, 20);
let sum2 = getSum(5, 16);

let max = sum1 > sum2 ? sum1 : sum2;
console.log(max);
```
说明: 函数是否需要返回值取决于是否有结果,并且这个结果是否需要在外部使用

问: return result 和 console.log(result)的区别 ?

> 返回值练习 

需求: 根据下面的模板, 计算不同学生的总成绩(将每科成绩累加), 并求出当中的最高分

```js
// 声明
function getScore(arr) { 
  

// 张三的分数数组
getScore([100, 90, 85]);
// 李四的分数数组
getScore([95, 92, 89]);
// 王五的分数数组
getScore([69, 100, 100]);
```

> 综合练习1

```javascript
1. 求任意半径的圆的面积, 并返回 => πr²  JS中, 使用 Math.PI 表示π
2. 求任意半径的圆的周长,并返回 => 2πr
3. 求任意2个数中的最大值, 并返回
```
> 综合练习2

```javascript
1. 求任意数组中的最大值并返回这个最大值
2. 求任意数组中的最小值并返回这个最小值
3. 翻转任意数组，返回一个新的数组
```
## 断点调试：

```javascript
console.log('代码开始执行');
function fn() {
    console.log('fn执行开始');
    console.log('fn执行结束');
}
fn();
console.log('代码执行结束');
```

说明:

1.	F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.	F10：单步调试（不进入函数的内部）
3.	F11：单步调试（进入函数内部）
4.	shift+F11：跳出函数内部

> 思考练习

```javascript
1. 求任意数的阶乘 => n的阶乘 => 1 * 2 * 3 * 4 * n 的结果
2. 求1 - n 之间所有阶乘的和
3. 求任意3个数中的最大值 
```
## 函数的细节补充
1. 两个相同的函数后面的会覆盖前面的函数

    ```js
    function fn() {
      console.log('哈哈');
    }
    function fn() {
      console.log('嘻嘻');
    }
    fn(); // 嘻嘻
    ```

2. 在Javascript中 实参的个数和形参的个数可以不一致

    1. 如果形参过多 会自动填上undefined (了解即可)

        ```js
        function test(a, b, c, d) {
          console.log(a, b, c, d); // 10 undefined undefined undefined ..
        }
        test(10)
        ```

    2. 如果实参过多 那么多余的实参会被忽略 (函数内部有一个arguments,里面装着所有的实参)

        ```js
        function test() {
          // 实参列表 => 函数内部拥有的一个关键字 => 将所有的实参存储在里面
          console.log(arguments);
        }
        test(10, 20, 30, 40);
        ```

        小练习: 求出参数列表中的最大值, 特点: 参数的个数是未知的情况

3. 函数一旦碰到return就不会在往下执行了  函数的结束用return

    ```js
    function test() {
      console.log('return之前');
      return 111;
      console.log('return之后');
    }
    console.log(test());
    ```

    1. return;的写法相当于return undefined;
    2. 思考: break的结束和return结束有什么区别 ? 
       1. break用于跳出循环 而return用于跳出函数
    3. 思考: 如何返回多个数据 ?
       1. 返回一个数据集合 (数组)


## 作用域 

> 作用域：变量起作用的区域

问题:

```js
function fn() {
	let a = 10;
}
fn();
console.log(a); // ?
```



### 作用域分类

>  全局作用域: 函数外面的区域
>
>  函数作用域(局部作用域): 函数内部的区域
>
>  块作用域: ?

### 变量分类

> 全局变量: 在函数外部let 的变量  => 全局变量在`任何区域`都可以访问和修改
>
> 局部变量: 在函数内部let 的变量  => 局部变量只能在`当前函数内部`访问和修改  

**`大坑:` 局部变量必须是函数里面声明过(let)的变量**

```js
let a = 10;

function fn() {
  a = 20;
  console.log(a);
}

fn();
console.log(a); // ?
```

技巧: 初学者可以通过绘图帮助自己理解

```
1. 先绘制出全局作用域和函数作用域
2. 找let的位置去确定是全局变量还是局部变量, 并且在对应的作用域里面绘制出来
```

###变量访问原则

> 在能够访问到的情况下 先局部 局部没有在找全局

```js
let a = 10;
function fn() {
  let a = 20;
  console.log(a); // ?
}
fn();
console.log(a); // ?
```

开胃小菜:

```js
function test() {
  let a = 20;
  console.log(a); 
}
test();
console.log(a);
// ------------------------------
let a = 10;
function test() {
  console.log(a); 
}
test();
console.log(a); 
// ------------------------------
let a = 10;
function test() {
  a = 20;
  console.log(a);
}
test();
console.log(a); 
```

思考：

```js
// 1、
let num1 = 11;
let num2 = 22;
function fn() {
  let num1 = 33;
  num1 = 44;
  num2 = 55;
  console.log(num1);
  console.log(num2);
}

fn();

console.log(num1);
console.log(num2);

// 2.
let num1 = 111;
let num2 = 222;

function fn(num1, num2) {
  num1 = 333;
  num2 = 444;
  console.log(num1);
  console.log(num2);
}

fn(num1, num2);

console.log(num1);
console.log(num2);

// 3.
let num1 = 111;
let num2 = 222;

// 形参本质上就是一个局部变量
function fn(num1) {
  num1 = 333;
  num2 = 444;
  console.log(num1);
  console.log(num2);
}

fn(num1, num2);

console.log(num1);
console.log(num2);
```

提问:

1. 什么是全局变量和局部变量? 各有什么特点 ?
2. 变量的访问原则 ?
3. 形式参数本质上是全局还是局部变量 ?

## 匿名函数与自执行函数 

### 匿名函数

> 匿名函数：没有名字的函数

```js
function () {} // 匿名函数
```

> 如何使用：

1. 将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为函数表达式

   ```js
   let a = function () {
     console.log('哈哈哈哈');
   };
   // 调用
   a();
   ```

2. 自执行（匿名函数自执行）

   ```js
   (function () {
     console.log('我太难了 只能自己调自己');
   })();
   ```

   场景介绍: 避免全局变量之间的污染

   ```js
   (function () {
     function fn() {
       console.log('这是我三哥的代码 功能及其牛叉');
     }
     fn();
   })();
   
   (function () {
     function fn() {
       console.log('这是我四哥的代码, 功能相当强大');
     }
     fn();
   })();
   ```
